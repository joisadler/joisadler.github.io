---
layout: post
comments: true
title:  "Неделя #9. Наконец-то практика!"
excerpt: "Йось, все фигня, давай по-новой!"
tags: [Eslint, Babel, NPM, package.json, es6, lodash, иммутабельность]
date:   2017-07-03 07:50:00 +0300
category: posts
---
Впервые за долгое время мне не стыдно начинать писать еженедельный пост, поскольку на этот раз действительно есть, чем похвалиться. Не то чтобы я сделал что-то грандиозное: создал сайт или какое-нибудь там работающее приложение, однако продвижение есть и это не  может не радовать.

На этой неделе главным моим  заданием было разобраться в структуре npm-пакета: каким образом он устроен, где должны лежать какие файлы, что такое package.json и для чего он нужен, что это за всякие странные файлы, начинающиеся с точки типа .eslintrs .и babelrc и в чем их предназначение. Для этого Кирилл дал мне ссылку на вот такой [репозиторий](https://github.com/hexlet-boilerplates/nodejs-package) и дал задание оформить мою собственную библиотеку с алгоритмами по такому же принципу, но не бездумно копируя, а только после того, как я действительно разберусь зачем нужна каждая отдельная деталь.

Чтобы справиться с задачей, для начала я стал разбираться в том что такое вообще npm, пакеты и как вообще это всё работает. В этом очень помогла [документация](https://docs.npmjs.com/) на официальном сайте. Кстати, на самом Хекслете есть мини-курс [JS: подготовка к работе](https://ru.hexlet.io/courses/javascript_setup), где тоже объясняется много полезных вещей по поводу настройки рабочего окружения и там тоже есть урок про npm, хотя, если честно, я его не совсем понял. Еще одно неплохое [видео](https://www.youtube.com/watch?v=2e0hbjtUT-4) по поводу npm также немного помогло мне пополнить свой "пазл" новыми фрагментами.

В итоге мне хорошо зашла вся эта модель работы npm-пакетов (по крайней мере, мне так кажется). Я понял что значит пакет, понял как работают зависимости, понял зачем нужен package.json, примерно понял в чем разница между просто зависимостями и dev-dependencies.

После этого стал разбираться с бабелем (или, если выражаться точно — бэйблом), его настройкой и использованием. Babel — это так называемый транспилятор или по-английски — транспайлер, задача которого состоит в том, чтобы переводить код, написанный с использованием передовых синтаксических конструкций в код, состоящий из более простого синтаксиса, понятного большему количеству браузеров, в том числе старым версиям. Для того, чтобы иметь возможность использовать его в своем проекте, недостаточно только лишь установить его вместе с нужными плагинами. Кроме этого, нужно еще настроить его, прописав нужные настройки в  специальном конфигурационном файле (тот самый загадочный .babelrc). После некоторого ознакомления, я установил себе консольную версию и опробовал бабель в работе над своим проектом. Во время работы над кодом я постоянно запускаю его в последней версии node.js и моя нода поддерживает синтаксис es6 из коробки. Однако с новым импортом модулей возникли трудности и именно здесь пригодился бабель. С его помощью я создал новый файл, который спокойно запустился и импортировал все, что было нужно. Единственное, в чем я не разобрался — это то, как автоматизировать весь этот процесс, чтобы все необходимые преобразования происходили самостоятельно. Подозреваю, что за это отвечает сборщик проекта, но как пользоваться этими сборщиками я пока еще не знаю.

Кстати, на выходных я таки доделал свои связные списки до рабочего состояния. А дело вот в чем. Когда я уже закончил работу над списком, я решил добавить ему еще один метод, проверяющий: является ли список зацикленным. Соответственно, для тестирования этого метода мне понадобилось создать такой зацикленный список. И когда он был готов, я вдруг обнаружил, что исходный список, который я использовал за основу, тоже изменился! Это означало, что мои списки на самом деле не были иммутабельными, как я изначально задумывал. Я понял, что все дело в созданном мной служебном методе clone, который создавал копию списка. Я стал разбираться в чем дело и почему метод работает некорректно и узнал, что на самом деле существует два вида клонирования объектов и в моём случае нужно глубокое клонирование. В итоге, промучавшись над решением этого вопроса почти все выходные, перелопатив весь stackoverflow и перепробовав кучу способов, я так и не смог реализовать глубокое клонирование самостоятельно. Знаний на этом этапе просто не хватило. Но надо было двигаться дальше и поэтому я не нашёл другого решения кроме как подключить к своему проекту библиотеку lodash и воспользоваться её функцией deepClone. Конечно, нехорошо, наверно, поступать так в учебном проекте, но зато по крайней мере все заработало как надо и списки стали действительно иммутабельными. А заодно еще попрактиковался с es6-импортом)

Вот, пожалуй, и все. Далее меня ждёт более глубокое погружение в тему пакетов, понимание того, как работают исполняемые файлы, также мне необходимо будет изучить, как подключать тесты.

Кирилл говорит, что на самом деле я уже вплотную подобрался к реальной разработке и к вебу и что этот месяц должен стать для меня прорывным. Будем на это надеяться, профессионалу со стороны виднее)

Ну и учиться, учиться и еще раз учиться!
